

DFS
#próximo_passo = verifica se a casa futura é válida;


percurso()
{
    #Direções Possíveis x+1(direita),x-1(esquerda) ou y-1(subir),y+1(descer):
    
    verifica as direções:
        só anda para direções na memória.
            prioriza na seguinte ordem: baixo, direita, cima, esquerda.
    
   while(próximo_passo() == true) 
        Passo_Busca_Profundidade();
    
    if Verifica_Redondezas(atual);
        Troca avanço;
    else
        while(Verifica_Redondezas == false)
            pop na pilha
            matrix[Direção.y + atual.y][Direção.x + atual.x] = '#';
        
    
    Matrix[Direção.y + atual.y][Direção.x + atual.x] = '#';
    if perigo{
        volta no começo
    }
        
    dá 1 passo
}



///
Passo_Busca_Profundidade(Coordenada *Posição_atual,Coordenada Direção)
{
    
        posição atual.x+= Direção.x
        posição atual.y+= Direção.y
        pega a posição atual armazena na pilha
    
  }  



BFS

CasasViaveisIniciais()
{
    Olha aos arredores:
        if(#):
            jump
        else:
            Lista.append(posição)
    return Lista
}

VerificaViáveis(&)
{
    Olhar para todos os lados

        if(i.Visited == True):
            jump
        else:
            viáveis.append(i)


    return viáveis     
}

RemoverAntigas(Adicionadas , Tamanho, &Lista)
{
    nRemoções = Tamanho-Adicionadas
    
    c = 0;

    while(c<nRemoções)
        c++
        Lista.remover()
}

Passo_Busca_Largura()
{

    Iteração atual:
      Lista = CasasViaveisIniciais()

      for i in Lista:

        if(VerificaViáveis(i, )):
            c++
            Matriz[Casa_Viável].Visited = True
            Lista.append(Casa_Viável)
        
    RemoverAntigas(c, Lista.length(), &Lista)
}


main()
{
    lê arquivo e obtem matriz gigante em variável
    
    iniciar percurso
    
    percurso();
    
}
